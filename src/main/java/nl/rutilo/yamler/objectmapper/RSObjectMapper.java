package nl.rutilo.yamler.objectmapper;

import nl.rutilo.yamler.collections.StringKeyMap;
import nl.rutilo.yamler.utils.Value;
import nl.rutilo.yamler.yamler.Yamler;

import java.lang.reflect.Array;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.function.Function;
import java.util.stream.Collectors;

import static nl.rutilo.yamler.collections.Collections2.firstOf;

/** Mapper that converts Maps to instances and back. This implementation currently only supports
  * classes that can be both serialized (instance to map) and deserialized (map to instance).
  * <pre>
  * There are various strategies for mapping:
  * - matching constructor parameters to public final fields (requires java -parameters option)
  * - builder (typically as generated by Lombok) and public final fields
  * - getters & setters
  * - public non-final fields and a default constructor
  * - class annotated with CustomMapper
  *
  * When mapping fails it is because none of these strategies could be adapted.
  *
  * To have a better chance of mapping to succeed (and generally good development rules):
  * - make your data objects final (if you need a change sometimes, use e.g. toBuilder())
  * - use simple field constructors (like those that are generated by @AllArgsConstructor)
  *   and/or a builder
  * - when logic is needed on construction, use a static 'createInstance' method that calls the
  *   simple field constructor
  */
@SuppressWarnings("unchecked")
public final class RSObjectMapper {
    private static final Map<Class<?>, ReflectionStrategy<?>> cachedReflectionStrategies =
        Collections.synchronizedMap(new HashMap<>());

    private RSObjectMapper() {}

    public static <T> T convert(final Class<T> clazz, StringKeyMap dataMap) {
        return getStrategy(clazz).createObjectFrom(dataMap);
    }
    public static <T> ReflectionStrategy<T> getStrategy(final Class<T> clazz) {
        final List<String> messages = new ArrayList<>();
        return (ReflectionStrategy<T>)cachedReflectionStrategies.computeIfAbsent(clazz, c ->
            Value.orSupplyValueExtends(
                () -> CustomMapperStrategy.createFor(clazz, messages),
                () -> ConstructorStrategy.createFor(clazz, messages),
                () -> BuilderStrategy.createFor(clazz, messages),
                () -> GettersSettersStrategy.createFor(clazz, messages),
                () -> PublicFieldsStrategy  .createFor(clazz, messages)
            )
          //.peek(s -> { System.out.println("Chosen strategy for " + clazz + ": " + s); })
            .orElseThrow(() -> new RSObjectMapperException("Don't know how to (de)serialize " + clazz.getName() + "\n - " + String.join("\n - ", messages)))
        );
    }

    public  static <T> T toTargetObject    (Object value, Class<T> targetType, Type genericType) { // NOSONAR -- high cc: just type checking
        if(value == null) {
            if(targetType == Optional.class) return (T)Optional.empty();
            if(targetType == Value.class) return (T) Value.absent();
            if(targetType == Boolean.class || targetType == Boolean.TYPE) return (T)(Boolean)false;
            if(targetType.isPrimitive()) return toTargetObject(0D, targetType, genericType);
            return null;
        }
        if(targetType == Object.class) return (T)value;
        if(targetType == String.class) return (T)value.toString();
        if(targetType == Integer.class || targetType == Integer.TYPE) return (T)(Integer)(value instanceof Number num ? num.intValue()    : Integer.parseInt   (value.toString()));
        if(targetType == Long.class    || targetType == Long.TYPE   ) return (T)(Long   )(value instanceof Number num ? num.longValue()   : Long   .parseLong  (value.toString()));
        if(targetType == Short.class   || targetType == Short.TYPE  ) return (T)(Short  )(value instanceof Number num ? num.shortValue()  : Short  .parseShort (value.toString()));
        if(targetType == Double.class  || targetType == Double.TYPE ) return (T)(Double )(value instanceof Number num ? num.doubleValue() : Double .parseDouble(value.toString()));
        if(targetType == Float.class   || targetType == Float.TYPE  ) return (T)(Float  )(value instanceof Number num ? num.floatValue()  : Float  .parseFloat (value.toString()));
        if(targetType == Byte.class    || targetType == Byte.TYPE   ) return (T)(Byte   )(value instanceof Number num ? num.byteValue()   : Byte   .parseByte  (value.toString()));
        if(targetType == Boolean.class || targetType == Boolean.TYPE) return (T)value;

        if(targetType.isArray()                   ) return toTargetArray(value, targetType, genericType);
        if(Set.class.isAssignableFrom(targetType) ||
           List.class.isAssignableFrom(targetType)) return toTargetCollection(value, targetType, genericType);
        if(Map.class.isAssignableFrom(targetType)) return toTargetMap(value, targetType, genericType);

        if(targetType == Optional.class) return value instanceof Optional ? (T)value : (T)Optional.of(value);
        if(targetType == Value.class)    return value instanceof Value ? (T)value : (T) Value.of(value);

        return Yamler.mapCollectionsToClass(value, targetType);
    }
    private static <T> T toTargetArray     (Object value, Class<T> targetType, Type genericType) {
        final Function<Integer,Object> getter;
        final int len;
        if(value.getClass().isArray()) {
            getter = index -> Array.get(value, index);
            len = Array.getLength(value);
        } else
        if(value instanceof List) {
            getter = ((List<?>) value)::get;
            len = ((List<?>)value).size();
        } else {
            throw new RSObjectMapperException("Cannot create array of " + value);
        }
        final Class<?> itemType = targetType == null ? Object.class : targetType.getComponentType();
        final Object target = Array.newInstance(itemType, len);
        for (int i = 0; i < len; i++) {
            Array.set(target, i, toTargetObject(getter.apply(i), itemType, genericType));
        }
        return (T) target;
    }
    private static <T> T toTargetCollection(Object value, Class<T> targetType, Type genericType) {
        if(targetType == null) throw new RSObjectMapperException("Unable to deserialize: no target type given for " + value);
        final Class<?> itemType = Value.or(getGenericTypeParameterOf(genericType), Object.class);
        if(!(value instanceof Collection)) throw unableToCreate(targetType, value);

        final boolean sameCollectionAndElementType =
            targetType.isAssignableFrom(value.getClass()) &&
            firstOf((Collection<?>)value)
             .map(v -> v.getClass().isAssignableFrom(itemType))
             .orElse(false);

        if(sameCollectionAndElementType) return (T)value;

        T result;

        if(List.class == targetType) result = (T)new ArrayList<>();
        else
        if(Set.class  == targetType) result = (T)new HashSet<>();
        else
            try {
                result = targetType.getConstructor().newInstance();
            } catch (InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
                if(List.class.isAssignableFrom(targetType)) result = (T)new ArrayList<>();
                else
                if(Set.class.isAssignableFrom(targetType)) result = (T)new HashSet<>();
                else {
                    throw new RSObjectMapperException("Unable to create target collection for type " + targetType, e);
                }
            }

        ((Collection<?>)value).stream()
            .map(item -> toTargetObject(item, itemType, itemType))
            .forEach(((Collection<Object>) result)::add);

        return result;
    }
    private static <T> T toTargetMap       (Object value, Class<T> targetType, Type genericType) {
        Class<?>[] itemTypes0 = getGenericTypeParametersOf(genericType);
        if(itemTypes0.length == 0 && genericType instanceof Class) itemTypes0 = new Class[] { String.class, (Class<?>)genericType };
        if(itemTypes0.length == 0) itemTypes0 = new Class[] { String.class, Object.class };
        if(itemTypes0.length != 2) throw new RSObjectMapperException("Unable to deserialize: don't know generic type of " + targetType + " for " + value); // NOSONAR
        if(itemTypes0[0] != String.class) throw new RSObjectMapperException("Unable to deserialize: only Maps with string keys are supported: " + targetType);
        if(!(value instanceof Map)) throw new RSObjectMapperException("Unable to create map from " + value);

        final Class<?>[] itemTypes = itemTypes0;
        class TempEntry {
            final String key;
            final Object value;
            TempEntry(String k, Object v) { key=k; value=v; }
        }
        return (T)((Map<String,?>)value).entrySet().stream()
                .map(e -> new TempEntry(e.getKey(), toTargetObject(e.getValue(), itemTypes[1], null)))
                .filter(e -> e.value != null)
                .collect(Collectors.toMap(e -> e.key, e -> e.value))
                ;
    }

    private static Class<?> getGenericTypeParameterOf(Type genericType) {
        Class<?> itemType = null;
        if(genericType instanceof ParameterizedType subType) {
            final String itemTypeName = subType.getActualTypeArguments()[0].getTypeName();
            try { itemType = Class.forName(itemTypeName); } catch (ClassNotFoundException failed) { /*keep null*/ }
        }
        if(genericType instanceof Class) {
            itemType = (Class<?>)genericType;
        }
        return itemType;
    }
    private static Class<?>[] getGenericTypeParametersOf(Type genericType) {
        if(genericType instanceof ParameterizedType subType) {
            return Arrays.stream(subType.getActualTypeArguments())
                    .map(Type::getTypeName)
                    .map(n -> {
                        try { return Class.forName(n); } catch (ClassNotFoundException failed) { return null; }
                    })
                    .toArray(Class[]::new)
                    ;
        }
        return new Class<?>[0];
    }
    public static RSObjectMapperException unableToCreate(Class<?> clazz, Object value) {
        return new RSObjectMapperException("Unable to create " + clazz + " from " + value);
    }
}
